\section{Abstract Types}
\label{sec:abs-types}

Here is a summary of the difficulties that can arise in practice when a package has a public type component:
\begin{itemize}
  \item Application code can access the public type's representation directly. If we wish to change the representation (e.g., to make it more efficient), we have to modify not only the package but also any application code that accesses the representation directly. (Such code could be anywhere in the application program. Even if there turns out to be no such code, we have to read the whole program to be sure.)
  \item The public type's representation might have improper values that do not correspond to any values of the desired type. Even if the package's procedures are programmed correctly not to generate improper values, faulty application code might generate improper values.
  \item The public type's representation might be non-unique. A simple equality test might then yield the wrong result.
\end{itemize}

To avoid these problems we need an alternative way to define a new type. An \textit{\textbf{abstract type}} is a type whose identifier is public but whose representation is private. An abstract type must be equipped with a group of \textit{\textbf{operations}} to access its representation. The operations are typically procedures and constants. The values of the abstract type are defined to be just those values that can be generated by repeated use of the operations.

In other words, \textit{internals of the datatype is hidden and only interface functions provide the access}.
\begin{formula}{Example}
  rational numbers: 3/4 , 2/5, 19/3
\begin{listing}[H]
\begin{minted}[bgcolor={}]{haskell}
  data Rational = Rat (Integer, Integer)
  x = Rat (3,4)
  add (Rat(a,b)) (Rat(c,d)) = Rat (a*d+b*c,b*d)
\end{minted}
\end{listing}

  What about
\begin{itemize}
  \item[] Invalid value? \texttt{Rat (3,0)}
  \item[] Multiple representations of the same value?
    \texttt{Rat (2,4) = Rat (1,2) = Rat(3,6)}
\end{itemize}
Solution: avoid arbitrary values by the user.
\end{formula}

It does not matter whether an abstract type's representation is non-unique, because the representation is private. The key point is that only desired properties of the abstract type can actually be observed by application code using the operations with which the abstract type is equipped.

We can easily change an abstract type's representation: we need change only the package body and the private part of the package specification. We can be sure that we need not change the application code, since the latter cannot access the representation directly.

We can classify operations on an abstract type $T$ as follows.
\begin{itemize}
  \item A \textit{constructor} is an operation that computes a new value of type $T$, possibly using values of other types but not using an existing value of type $T$.
  \item A \textit{transformer} is an operation that computes a new value of type $T$, using an existing value of type $T$.
  \item An \textit{accessor} is an operation that computes a value of some other type, using an existing value of type $T$.
\end{itemize}
In general, we must equip each abstract type with \textit{at least one constructor}, \textit{at least one transformer}, and \textit{at least one accessor}. Between them, the constructors and transformers must be capable of generating all desired values of the abstract type.
\end{multicols*}

\begin{formula}{}

Main purpose of abstract data types is to use them transparently (as if they were built-in) without loosing data integrity.
\begin{listing}[H]
\begin{minted}[bgcolor={},escapeinside=\#\#]{haskell}
module Rational(#\color{red}{Rational,rat,add,subtract,multiply,divide}#) where
  data Rational = #\color{gray}{Rat}# (Integer,Integer)
  rat (x,y) = simplify (Rat(x,y))
  add (Rat(a,b)) (Rat(c,d)) = rat (a*d+b*c,b*d)  
  subtract(Rat(a,b)) (Rat(c,d)) = rat (a*d-b*c,b*d)  
  multiply(Rat(a,b)) (Rat(c,d)) = rat (a*c,b*d)
  divide (Rat(a,b)) (Rat(c,d)) = rat (a*d,b*c)
  #\color{gray}{gcd}# x y = if (x==0) then y
                            else if (y==0) then x
                            else if (x<y) then gcd x (y-x)
                            else gcd y (x-y)
  #\color{gray}{simplify}# (Rat(x,y)) = if y==0 then error "invalid value"
                                        else let a=gcd x y 
                                        in Rat(div x a, div y a)
\end{minted}
\end{listing}
\end{formula}

\begin{multicols*}{2}
\setlength{\columnsep}{1.5cm}
\setlength{\columnseprule}{0.2pt}
