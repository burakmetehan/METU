\section{Grammars}
\label{sec:grammars}

Turing machines can be reasonably called \textit{automata}. Like other automata, Turing machines and their extensions act basically as \textit{language acceptors}, receiving an input, examining it, and expressing in various ways their approval or disapproval of it. Two important families of languages, the recursive and the recursively enumerable languages, have resulted. 

Additionally, there is another important family of devices (other than language acceptors), very different in spirit from language acceptors, that can be used to define interesting classes of languages: \textit{language generators}, such as regular expressions and context-free grammars. In fact, It has been demonstrated that these two formalisms provide valuable \textit{alternative characterizations} of the classes of languages defined by language acceptors. 

We shall now introduce a new kind of language generator that is a generalization of the the context-free grammar, called the \textbf{grammar} (or \textbf{unrestricted grammar}, to contrast it with the context-free grammars) and show that the class of languages generated by such grammars is precisely the class of recursively enumerable ones. 

\begin{definition}{}
A \textbf{grammar} (or \textbf{unrestricted grammar}, or a \textbf{rewriting   system}) is a quadruple $G = (V, \Sigma, R, S)$, where
\begin{itemize}
  \item $V$ is an alphabet; 
  \item $\Sigma \subseteq V$ is the set of \textbf{terminal} symbols, and $V - \Sigma$ is called the set of \textbf{nonterminal} symbols;
  \item $S \in V - \Sigma$ is the \textbf{start} symbol; and
  \item $R$, the set of \textbf{rules}, is a finite subset of ${(V^*(V - \Sigma)V^*) \times V^*}$.
  %$([\textit{Any string containing at least one nonterminal}] \times [\textit{Any string}])$.
\end{itemize}

\quad We write $u \ra v$ if $(u,\ v) \in R$; we write $u \Ra_G v$ if and only if, for some $w_1, w_2 \in V^*$ and some rule $u' \ra v' \in R$, $u = w_1u'w_2$ and $v = w_1v'w_2$.

\quad As usual, $\Ra_G^*$ is the reflexive, transitive closure of $\Ra_G$. A string $w \in \Sigma^*$ is generated by $G$ if and only if $S \Ra_G^* w$; and $L(G)$, the \textbf{language generated by} $G$ is the set of all strings in $\Sigma^*$ generated by $G$.

\quad We also use other terminology introduced originally for context-free grammars; for example, a \textbf{derivation} is a sequence of the form ${w_0 \Ra_G w_1 \Ra_G \cdots \Ra_G w_n}$.
\end{definition}

Grammars play with respect to Turing machines precisely the same role that context-free grammars play in relation to pushdown automata, and regular expressions to finite automata:
\begin{theorem}{}
  A language is generated by a grammar if and only if it is recursively enumerable.  
\end{theorem}
\begin{proof}
  \textbf{\textit{Read proof from the textbook, {pp. 230-231}}}.
\end{proof}

\vspace*{\fill}
\columnbreak

\begin{example}{}
The following grammar $G$ generates the language $\{ a^nb^nc^n\ |\ n \geq 1 \}$. $G = (V,\ \Sigma,\ R,\ S)$, where
\begin{align*}
  V = \{ &S,\ a,\ b,\ c,\ A,\ B,\ C,\ T_a,\ T_b,\ T_c \},\\
  \Sigma = \{ &a,\ b,\ c \}, \textnormal{and}\\
  R = \{
      &S \ra ABCS, \\
      &S \ra T_c,  \\
      &CA \ra AC,  \\
      &BA \ra AB,  \\
      &CB \ra BC,  \\
      &CT_c \ra T_cc,  \\
      &CT_c \ra T_bC,  \\
      &BT_b \ra T_bb,  \\
      &Bn \ra T_ab,  \\
      &AT_a \ra T_aa,  \\
      &T_a \ra e
  \}
\end{align*}
\begin{itemize}
  \item The first three rules generate a string of the form $(ABC)^nT_c$.
  \item Then the next three rules allow the $A$'s, $B$'s, and $C$'s in the string to ``sort out'' themselves correctly, so that the string becomes $A^nB^nC^nT_c$.
  \item Finally, the remaining rules allow the $T_c$ to ``migrate'' to the left, transforming all $C$'s to $c$'s, and then becoming $T_b$. In turn, $T_b$ migrates to the left, transforming all $B$'s into $b$'s and becoming $T_a$, and finally $T_a$ transforms all $A$'s into $a$'s and then is erased.
\end{itemize}
\end{example}

\begin{definition}{}
Let $G = (V, \Sigma, R, S)$ be a grammar, and let $f\ :\ \Sigma^* \mapsto \Sigma^*$ be a function. $G$ \textbf{computes} $f$ if for all $w, v \in \Sigma^*$, the following is true,
\begin{equation*}
  SwS \Ra_G^* v \textnormal{ if and only if } v = f(w)
\end{equation*}
That is, the string consisting of the input $w$, with a starting symbol of $G$ on each side, yields exactly one string in $\Sigma^*$: the correct value of $f(w)$. 

\quad A function $f\ :\ \Sigma^* \mapsto \Sigma^*$ is \textbf{grammatically computable} if and only if there is a grammar $G$ that computes it.
\end{definition}

\begin{theorem}{}
A function $f\ :\ \Sigma^* \mapsto \Sigma^*$ is recursive if and only if it is grammatically computable.
\end{theorem}

\vspace*{\fill}
\columnbreak
